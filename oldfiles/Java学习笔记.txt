封装：
1.Java内部类
    -->什么是内部类：
        内部类就是定义在另一个类里面的类，与之对应的包含内部类的类称为外部类。
    -->为什么要将一个类定义在另一个类里面？
        -->内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其它类访问该类
        -->内部类的方法可以直接访问外部类的所有数据，包括私有的数据
        -->内部类所实现的功能使用外部类同样可以实现，只是有时候使用内部类更方便
    -->内部类有几种：
        -->成员内部类
        -->静态内部类
        -->方法内部类
        -->匿名内部类
    -->如果内部类变量和外部类重名则在内部类调用外部类非静态变量时需要使用外部类名.this.变量名（如果是访问外部类静态变量的话可以直接使用外部类名.外部静态变量名进行访问)
    -->静态内部类：
        -->静态内部类不能直接访问外部类的非静态变量，但是可以通过类名.变量名（这里跟非静态内部类访问非静态外部类变量相差一个this）
        -->如果访问外部类同名静态变量可以直接使用外部类名.变量名进行访问
        -->创建内部类对象时就不需要先创建外部类对象了
    -->方法内部类
        -->方法内部类只能在本方法内使用
        -->方法内部类不能使用访问修饰符进行修饰，也不能使用static进行修饰
        Ex：
            //外部类
            public class HelloWorld {
                private String name = "爱慕课";
                // 外部类中的show方法
                public void show() { 
                    // 定义方法内部类
                    class MInner {
                        int score = 83;
                        public int getScore() {
                            return score + 10;
                        }
                    }
                    // 创建方法内部类的对象
                    MInner m = new MInner();
                    // 调用内部类的方法
                    int newScore = m.getScore();
                    System.out.println("姓名：" + name + "\n加分后的成绩：" + newScore);
                }
                // 测试方法内部类
                public static void main(String[] args) {
                    // 创建外部类的对象
                    HelloWorld mo = new HelloWorld();
                    // 调用外部类的方法
                    mo.show();
                }
            }
    
继承：
    继承是类与类的一种关系，“is a”的关系
    子类不能继承父类中被private修饰的数据
    在创建子类对象的时候先初始化父类，后初始化子类
    -->初始化顺序
        -->父类对象
        -->父类属性初始化
        -->父类构造方法初始化
        -->子类对象
        -->子类属性初始化
        -->子类构造方法初始化
    如果子类构造方法中既没有显示调用父类构造方法，而父类又没有无参的构造方法，则编译出错

Object类：
    Object类是Java中所有的类的父类，如果一个类没有使用extends关键字明确表示继承另外一个类，那么这个类默认继承Object类。
        -->toString()方法，如果在输出一个对象的时候会输出一个对象地址字符串（哈希码），如果希望在输出这个对象的时候输出的是这个对象的属性那么只需要重写toString方法就可以了

        -->equals()方法：比较的是对象的引用是否指向同一块内存地址。一般情况下比较两个对象时比较他的值是否一致，所以需要进行重写
            -->在比较两个对象是需要重写这个方法的原因是：
                -->equals方法在Object类型中仅仅比较的是两个对象的引用是否相同,这个和==是一样的
                -->再比较字符串时，使用==比较的是字符串的引用，如果使用直接赋值方式也是可以使用==来进行字符串的值是否相等，因为直接赋值的方式是使用常量池，而是用创建对象的方式就不行了，因为在String类中已经对equals()方法进行重写了，所以在比较是我们直接使用就可以了
多态：
    对象的多种形式
    1.引用多态：
        -->父类的引用可以指向本类的对象
        -->父类的引用可以指向子类的对象（子类的引用不可以指向父类的对象）
    2.方法多态：
        -->创建本类方法的时候，调用的是本类的方法
        -->创建子类对象时，调用的是重写的方法，如果没重写则调用的是父类中的方法
        Ex：
            Animal dog1 = new Animal();
            Dog dog2 = new Animal();
            dog1.eat();//调用的是Animal类中的方法eat
            dog2.eat();//调用的是Dog类中重写的方法eat。如果没重写则调用的是Animal类中的eat方法

instanceof 关键字可以判断一个引用是否是某个类型或者是某个类型的子类型

接口：
